#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     compass,        sensorVirtualCompass)
#pragma config(Motor,  mtr_S1_C1_1,     RightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RightBack,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftFront,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     LeftBack,      tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//IMPORTANT ---> notice none of the motors are reversed, you also need a compass sensor in order for
//the driving system to work. To use with your robot just adjust the ports for the motors and sensors

///////////////////////////////// CONTROLS /////////////////////////////////
//                                                                        //
//  Left Joystick  ---> move up, down, left, and right                    //
//  Right Joystick ---> turn the robot when moving on the X axis          //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

long InAngle = SensorValue(compass);
//This variable takes the first value of the compass, so that it can be used
//with the newest value of the compass to show how much the robot has turned
//this function is shown in the second function in the while function
task main()
{
	while(true)
	{
	  long ActAngle = SensorValue(compass);
	  long deltaAng = ActAngle-InAngle;
	  //These variables detect the change in angle
	  long X = (joy1_x1*Cos((deltaAng*PI)/180)) + (joy1_y1*sin((deltaAng*pi)/180));
	  long Y = (joy1_y1*Cos((deltaAng*PI)/180)) - (joy1_x1*sin((deltaAng*pi)/180));
	  //The 2 variables above 'turn' around the values friom the x & y in the
	  //first joystick using as a reference the 'deltaAng' variable

	  motor(LeftFront) = X+Y+joy1_x2;
	  motor(LeftBack) = Y-X+joy1_x2;
	  motor(RightFront) = X-Y+joy1_x2;
	  motor(RightBack) = joy1_x2-X-Y;
	  //These algorithms manipulate the x and y variables for the different wheelts to create an
	  //omnidirectional driving system that is oriented with the field
	 }
}
